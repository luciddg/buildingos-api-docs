FORMAT: 1A

# BuildingOS API

We anticipate our API will be used by the following people: 
- Developers to build apps used by BuildingOS customers
- Customers who want access to their raw data
- Students who are part of school energy competitions

If you interested in large amounts (GBs) of anonymous data for research or simulation purposes. Please contact us at <insert-email-here>. 
We can provide access to large datasets but not through this API. 

# Getting access 
Access to the API will require an authorization token. Authorization is handled using the OAuth2.0 standard. To generate an authorization token you will need to first register an OAuth Client within BuildingOS. You will then need to use this OAuth client details to generate an authorization token using the standard 3-legged OAuth handshake. See <oauth_2_spec_url> for more details.

## NOTE: All API requests must be over HTTPS

## Access requests and registering API clients

For OAuth2.0 client access:

In order to make requests on behalf of a user, the client needs to be authorized by the user. All clients must use OAuth2.0 to connect with BOS on behalf of a BOS user. To register a new client, login to BOS and navigate to the API app. In this area of BuildingOS you will be able to view/update/delete API clients. You can create as many clients as you like. We recommend you create at least two, one for "production" and one for "development". You will need to name the client, provide a description and contact email. These will be presented to the user during the authorization flow. Once created, the BOS system will generate a clientID and secret to use during your applications authorization process.

## Authorization Token Expiration
A user's authorization token key has a short lifetime. Each token only lasts one hour. A user's authorization token can be revoked either by the user or a system administrator. A client consuming the API would need to be prepared to support the use case of an authorization token expiring or being revoked. It should handle re-requesting access using the refresh token provided along side the access token.

# Response Object Format
All objects returned from the API are in a data envelope. This means the object resource is not returned as the root of the json response object but rather, the object is wrapped in an enclosing object. This allows us to make changes to the response object to add additional meta data (if needed) as the API evolves. For most requests the response object will have these three attributes. Most singular resource requests (e.g. /meters/XYZ) will just have the 'data' attribute. Most collection requests will have 'data', 'links', and 'total_count'. (Note: `error` responses are different. See below for details...)

The possible object attributes are: 

`data` - Contains the JSON serialized object or an array of objects.

`links` -  Contains pagination support (when appropriate, when not appropriate the "links" attribute should be present but an empty object can be returned).

`total_count` - the total database count of all the objects of this type that match the params in the request but (in the case of pagination) may not be returned. Note: filters may affect the total_count.

`meta` - Information on the model object attributes for controlled vocabularies and support for object creation/validation. 

# Formatting
For all compound url components and attributes will use "sake_case". For example "pending_notifications", "user_id", etc... You will not see attribute names like "pendingNotifications" or "user-id"

# Dates/Times/Timestamps 
All datetime or timestamps will be be returned as a string in UTC in RFC 3339 format (e.g. `'2012-04-23T18:25:43.511Z'`). For attributes that are a timestamp they will follow the convention of ending with `_at`. If there is a attribute that returns a date with no time component it will end in `_on`, be in this format `YYYY-MM-DD` and be the UTC adjusted Date equivalent of `2014-11-23T00:00:0.0Z`. In addition, if the object has a calculated local time this will be returned with the ending `_local`. For example, a Building has location and inherits the timezone of the area where it is located. If you request information on one of the meters in this building to find out the time of its last successful reading it will have two timestamps for this value. One timestamp, `last_reading_at` will be in UTC and `last_reading_local` will be the timestamp in the local timezone. If the building was located in the PST timezone and the `last_reading_at` value is `'2014-12-03T18:53:24Z'` and the `last_reading_local` will be `'2014-12-03T18:53:24-08:00'`.

[ref: https://tools.ietf.org/html/rfc3339]

# Pagination 
Certain API endpoints support pagination. We will only return the default record count if you do not specify a per_page. Note: There is a hard API per_page at 100 records. We paginate slightly differently depending on the characteristics of the data being requested. For resource objects like buildings we use the standard, known quantity pagination. For time based data like meter readings, we use time-based pagination. 


## Known quantity pagination

For objects where we can easily count like users, buildings, meters, etc... We use the following pagination scheme. In the request URL pass in the attributes below:
- `per_page` - Number of results to return (default = 100)
- `page` - Number to start returning results (default = 0)
`Note: on endpoints where the data set is larger than the record per_pages then inside the data payload will be a "links" attribute. This is here for client convenience. The "links" attribute will contain a "previous" attribute, and a "next" attribute. These will both be links to paginate through the data set. In addition, there will be an attribute called "total_count" in the top level payload. This contains the number of total records available. When you have reached the end or beginning of the data set one or both of the "previous" and "next" links may be null. `

```
{   
    ...
    "links" {
        "next": "https://api.buildingos.com/users/notifications?per_page=2&page=2",
        "previous": "https://api.buildingos.com/users/notifications?per_page=2&page=0"
    },
    "total_count": 200
}

```

## Time-based pagination
For data that is timebased readings we have a slightly different way to paginate. Since these data values have an explicit order we provide the ability to page through using "sliding windows". Since it is not possible to get an accurate count of the number of data values we do not provide a "total_count".
- `start` - The timestamp where you would like the data to start (RFC 3339 format).
- `end` - The timestamp where you want the data to end (RFC 3339 format).
- `order` - The order of the returned data `asc` or `desc` (default is `asc`)
- `per_page` - The number of items to return in the page

```
{   
    ...
    "links" {
        "next": "https://api.buildingos.com/meters/<meter_id>/data?resolution=day&start=2015-03-01&end=2015-04-01",
        "previous": "https://api.buildingos.com/meters/<meter_id>/data?resolution=day&start=2015-01-01&end=2015-02-01"
    }
}

```


# Definitions 
Many of the BuildingOS API endpoints return objects that contain attributes from our controlled vocabulary. The controlled vocabulary allows us to restrict the values of certain attributes to known-good types. These are typically the type of lists of controlled vocabulary used in dropdowns or multiselect UI elements. The `/meters` endpoint has several attributes that use a controlled vocabulary. One example of this is the 'reading_type' attribute. For this attribute you can only select known types of readings such as "Electricity", "Wind Speed", "Heating", "Cooling", etc... In the attribute for the object, the value returned will be the "slug" (a url compatible version) of the `reading_type`. Other values that could be used for the 'reading_type' are defined in the 'meta' section of the object payload under 'definitions'. The field name of the object, in this case 'reading_type', will be listed out. Following the url in the attribute value will return a list of the possible 'reading_type' objects.

```
 "meta": {
        "definitions": {
            "status": "https://api.buildingos.com/definitions/meters_status", 
            "source_units": "https://api.buildingos.com/definitions/meters_source_unit", 
            "reading_type": "https://api.buildingos.com/definitions/meters_reading_type", 
            "default_timescale": "https://api.buildingos.com/definitions/meters_default_timescale", 
            "display_units": "https://api.buildingos.com/definitions/meters_display_unit", 
            "scope": "https://api.buildingos.com/definitions/meters_scope"
        }
  }

```

An object controlled vocabulary definition object has the following construction:
```
  {
      "id": "1", 
      "displayName": "Electricity", 
      "slug": "electricity", 
      "optgroup": "Primary Resources", 
      "zeroUseMessage": "No electricity has been consumed during this period", 
      "avatar": "electricity.png", 
      "swf": "ico_electricity", 
      "icon": "bolt orange"
  }, 

```

# Expected Responses 
We expect that most of our endpoints will return the following responses in these general cases
- `GET` returns a 200, 204, or 206.
- `HEAD` returns a 205

Note: For some GET requests you may receive a 301. This will happen if you do not append a trailing slash to the end of your URLs.  To ensure your client code more robust make sure the HTTP client you use is capable of following redirects and that you have that flag/option enabled. For example, when using curl from the command line you should use the `-L` option. 
```
curl -v -X GET -L -H "Authorization: Bearer <ACCESS_TOKEN>" https://api.buildingos.com/buildings
```


# HTTP Response Codes

- `200` - OK - Everything is swell 
- `206` - OK - The resource was partially updated 

- `301` - Permanent Redirect - The resource has moved permanently 
- `304` - Not Modified - The client can use cached data

- `400` - Bad Request - The request was invalid or cannot be served. The exact error should be explained in the error payload. E.g. "The JSON is not valid"
- `401` - Unauthorized - The request requires an user authentication
- `403` - Forbidden - The server understood the request, but is refusing it or the access is not allowed.
- `404` - Not found - There is no resource behind the URI.
- `422` - Unprocessable Entity - Should be used if the server cannot process the entity, e.g. if an image cannot be formatted or mandatory fields are missing in the payload.

- `500` - Internal Server Error - Something went really wrong.

# On Nulls or Empty lists
Sometimes it is confusing what types of things to return when data is missing or not applicable. Here's our convention for returning empty things and nulls (based on this https://jtechies.blogspot.nl/2012/07/item-43-return-empty-arrays-or.html)

|       Should be        | When empty |
|------------------------|------------|
| Array of things        | []         |
| Object with properties | {}         |
| String                 | null or "" | 
| Number                 | null       |
|                        |            |

Some examples...
For an organization with no Buildings, normally an array of building ID strings.
```
   ...
   "buildings": [],
   ...
```

For a building with no GeoLocation, normally an object with "location": {"lat": 34.020576, "lon": -118.398035} 
```
   ...
   "location": {},
   ...
```
Note: sometimes for user entered fields like names, descriptions, etc... expect that values could be null or ""

# Misc

## Sources of Inspiration
https://jsonapi.org/format/
https://github.com/apiaryio/api-blueprint/blob/master/examples/Real%20World%20API.md
https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api
https://stateless.co/hal_specification.html
https://stackoverflow.com/questions/10286204/the-right-json-date-format
